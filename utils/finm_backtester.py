import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression

"""
BacktestSim class is a simple backtesting simulator that takes in close price data and trading signals to simulate a trading strategy.

Parameters:
- close_price: pd.Series, historical close price data
- signal: pd.Series, trading signals generated by the strategy
- initial_cash: float, initial cash to start the simulation
- transaction_cost: float, transaction cost per trade
- slippage: float, slippage factor

Methods:
- run: run the backtest simulation
- exit_all_positions: exit all open positions
- calculate_metrics: calculate performance metrics of the strategy
"""

class BacktestSim:
    def __init__(self, close_price, signal, initial_cash=100_000, transaction_cost=0.001, slippage=0.0):
        self.close_price = close_price
        self.signal = signal
        self.initial_cash = initial_cash
        self.transaction_cost = transaction_cost
        self.slippage = slippage
        self.open_buy_positions = []
        self.trades = []
        self.portfolio = []
        self.realized_pnl = []
        self.metrics = {}
        
        self.cash = self.initial_cash
        self.position = 0
        self.portfolio_value = self.initial_cash
        self.transaction_fees = 0
        self.cumulative_pnl = 0
    
    def run(self, sizing_strategy="fixed", **sizing_params):

        for i in range(len(self.close_price)):
            if self.close_price.index[i] == self.close_price.index[-1]:
                self.exit_all_positions()
                break
            price = self.close_price[i]
            adjusted_price = price * (1+self.slippage) if self.signal[i] == 1 else price * (1-self.slippage)

            if sizing_strategy == "fixed":
                fixed_size = sizing_params.get('fixed_size', 1)
                bet_size = self.portfolio_value * fixed_size
            else:
                bet_size = self.portfolio_value

            if self.signal[i] == 1: # buy signal
                num_shares = bet_size // adjusted_price
                cost = num_shares * adjusted_price
                fee = cost * self.transaction_cost
                cost_w_fee = cost + fee
                if self.cash >= cost_w_fee:
                    print("Buying {} shares at price {}".format(num_shares, adjusted_price))
                    self.cash -= cost_w_fee
                    self.open_buy_positions.append({"date": self.close_price.index[i],
                                                    "buy_price": adjusted_price,
                                                    "shares": num_shares}
                    )

                    self.position += num_shares
                    self.transaction_fees += fee
            
                    self.trades.append({"date": self.close_price.index[i],
                                        "price": adjusted_price,
                                        "action": "buy",
                                        "num_shares": num_shares,
                                        "cash": self.cash,
                                        "transaction_cost": fee,
                                        "position": self.position,
                                        "pnl": 0})                   
                
            elif self.signal[i] == -1 and self.position > 0: # sell signal
                shares_to_sell = sum(x['shares'] for x in self.open_buy_positions)
                total_proceeds = 0
                total_cost = 0
                total_pnl = 0
                print("Selling {} shares at price {}".format(shares_to_sell, adjusted_price))
                while shares_to_sell > 0 and self.open_buy_positions:
                    position_sell = self.open_buy_positions[0]
                    sell_shares = min(shares_to_sell, position_sell['shares'])
                    proceeds = sell_shares * adjusted_price
                    fee = sell_shares * position_sell['buy_price'] * self.transaction_cost
                    cost_w_fee = fee + sell_shares * position_sell['buy_price']
                    markout = proceeds - cost_w_fee
                    total_proceeds += proceeds
                    total_cost += fee
                    total_pnl += markout

                    self.open_buy_positions[0]['shares'] -= sell_shares
                    shares_to_sell -= sell_shares
                    self.position -= sell_shares

                    if self.open_buy_positions[0]['shares'] == 0:
                        self.open_buy_positions.pop(0) 

                self.transaction_fees += total_cost
                self.cash += total_proceeds * (1-self.transaction_cost)
                self.cumulative_pnl += total_pnl

                self.realized_pnl.append(total_pnl)

                trade_detail_dict = {
                    "date": self.close_price.index[i],
                    "price": price,
                    "action": "sell",
                    "num_shares": sell_shares,
                    "cash": self.cash,
                    "transaction_cost": total_cost,
                    "position": self.position,
                    "pnl": total_pnl
                }
                self.trades.append(trade_detail_dict)
            
            self.portfolio_value = self.cash + sum(x['shares']*price for x in self.open_buy_positions)

            portfolio_detail_dict = {
                "date": self.close_price.index[i],
                "action": "BUY" if self.signal[i] == 1 else "SELL" if self.signal[i] == -1 else "HOLD",
                "positions": self.position, 
                "cash": self.cash,
                "transaction_fees": self.transaction_fees,
                "position_values": sum(x['shares']*price for x in self.open_buy_positions),
                "portfolio_values": self.portfolio_value,
                "cumulative_pnl": self.cumulative_pnl
            }
            self.portfolio.append(portfolio_detail_dict)

        self.portfolio = pd.DataFrame(self.portfolio).set_index('date')

        return self.portfolio

    def exit_all_positions(self):
        if len(self.open_buy_positions)==0:
            print("No open positions to exit")
            return
        
        last_price = self.close_price[-1]
        total_proceeds = 0
        total_cost = 0
        total_pnl = 0

        for position in self.open_buy_positions:
            sell_shares = position['shares']
            proceeds = sell_shares * last_price
            fee = sell_shares * position['buy_price'] * self.transaction_cost
            cost_w_fee = sell_shares * position['buy_price'] + fee
            pnl = proceeds - (cost_w_fee)

            total_proceeds += proceeds
            total_cost += fee
            total_pnl += pnl
            self.position -= sell_shares

        self.cash += total_proceeds * (1-self.transaction_cost)
        self.transaction_fees += total_cost
        self.cumulative_pnl += total_pnl
        
        self.open_buy_positions = []
        self.realized_pnl.append(total_pnl)
        self.trades.append({"date": self.close_price.index[-1],
                            "price": last_price,
                            "action": "sell",
                            "num_shares": sell_shares,
                            "cash": self.cash,
                            "transaction_cost": total_cost,
                            "position": 0,
                            "pnl": total_pnl})
        
        self.portfolio_value = self.cash
        
        portfolio_detail_dict = {
                "date": self.close_price.index[-1],
                "action": "SELL",
                "positions": self.position, 
                "cash": self.cash,
                "transaction_fees": self.transaction_fees,
                "position_values": 0,
                "portfolio_values": self.portfolio_value,
                "cumulative_pnl": self.cumulative_pnl
        }

        self.portfolio.append(portfolio_detail_dict)
        self.trades = pd.DataFrame(self.trades).set_index('date')
    
    def calculate_metrics(self, adj=12, risk_free_rate=0.04, benchmark=False):
        benchmark_df = self.close_price.to_frame('returns').pct_change().dropna()
        risk_free_rate = risk_free_rate / adj

        if benchmark:
            df = benchmark_df.copy()
            win_rate = (df > 0).mean()
        else:
            df = self.portfolio['portfolio_values'].pct_change().to_frame('returns').dropna()
            trades_df = self.trades
            win_rate = (trades_df.pnl>0).mean()
            

        summary_stats = df.mean().to_frame('annualized_mean').apply(lambda x: x*adj)
        summary_stats['annualized_std'] = df.std() * np.sqrt(adj)
        summary_stats['sharpe_ratio'] = summary_stats['annualized_mean'] / summary_stats['annualized_std']
        summary_stats['sortino_ratio'] = summary_stats['annualized_mean'] / df[df < 0].std() * np.sqrt(adj)
        summary_stats['win_rate'] = win_rate
        summary_stats['skewness'] = df.skew()
        summary_stats['excess_kurtosis'] = df.kurtosis()
        summary_stats['var_95'] = df.quantile(0.05)
        summary_stats['cvar_95'] = df[df < summary_stats['var_95']].mean()
        summary_stats['min'] = df.min()
        summary_stats['max'] = df.max()

        summary_stats['tracking_error'] = np.sqrt(np.mean((df['returns'] - benchmark_df['returns'])**2))*np.sqrt(adj)
        summary_stats['information_ratio'] = (summary_stats['annualized_mean'] - benchmark_df['returns'].mean()) / summary_stats['tracking_error']
        
        X = benchmark_df.values.reshape(-1,1)
        y = df['returns'].values
        model = LinearRegression()
        model.fit(X, y)
        portfolio_beta = model.coef_[0]
        summary_stats['treynor_ratio'] = (summary_stats['annualized_mean'] - risk_free_rate) / portfolio_beta

        expected_return = risk_free_rate + portfolio_beta * (benchmark_df['returns'].mean() - risk_free_rate)
        summary_stats['jensens_alpha'] = summary_stats['annualized_mean'] - expected_return

        wealth_index = 1000 * (1+df).cumprod()
        previous_peaks = wealth_index.cummax()
        drawdowns = (wealth_index - previous_peaks) / previous_peaks

        summary_stats['max_drawdown'] = drawdowns.min()
        summary_stats['peak'] = [previous_peaks[col][:drawdowns[col].idxmin()].idxmax() for col in previous_peaks.columns]
        summary_stats['bottom'] = drawdowns.idxmin()
        
        recovery_date = []
        for col in wealth_index.columns:
            prev_max = previous_peaks[col][:drawdowns[col].idxmin()].max()
            recovery_wealth = pd.DataFrame([wealth_index[col][drawdowns[col].idxmin():]]).T
            recovery_date.append(recovery_wealth[recovery_wealth[col] >= prev_max].index[0])
        
        summary_stats['recovery_date'] = recovery_date
        return summary_stats